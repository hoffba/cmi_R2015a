function [tree_extended] = load_and_process_tree(X, vox_filepath)
    % Create Python script for loading VOX and processing tree
    python_path = update_python_paths();
    python_script = sprintf([...
        'import numpy as np\n',...
        'import random\n',...
        '# Set consistent random seed\n',...
        'seed_value = 42\n',...
        'np.random.seed(seed_value)\n',...
        'random.seed(seed_value)\n',...
        'import pickle\n',...
        'import elpigraph\n',...
        'import networkx as nx\n',...
        'import igraph\n',...
        'from scipy.io import savemat, loadmat\n',...
        'from elpigraph.src.core import PartitionData\n',...
        'from elpigraph.src.reporting import project_point_onto_graph, project_point_onto_edge\n',...
        'import copy\n\n',...
        'def prune_tree(tree_elpi):\n',...
        '    # Implemented similar to prune_the_tree() in the Python code\n',...
        '    old_tree = copy.deepcopy(tree_elpi)\n',...
        '    # Extract edge connections - handle tuple format correctly\n',...
        '    if isinstance(tree_elpi["Edges"], tuple):\n',...
        '        edges = tree_elpi["Edges"][0]\n',...
        '        edge_weights = tree_elpi["Edges"][1] if len(tree_elpi["Edges"]) > 1 else None\n',...
        '    else:\n',...
        '        edges = tree_elpi["Edges"]\n',...
        '        edge_weights = None\n',...
        '    \n',...
        '    nodes_positions = tree_elpi["NodePositions"]\n',...
        '    \n',...
        '    g = igraph.Graph()\n',...
        '    g.add_vertices(len(nodes_positions))\n',...
        '    labels = list(range(len(nodes_positions)))\n',...
        '    g.vs["label"] = labels\n',...
        '    g.add_edges(edges)\n',...
        '    \n',...
        '    # Find nodes to remove\n',...
        '    degs = g.degree()\n',...
        '    list_to_remove = []\n',...
        '    for e in g.get_edgelist():\n',...
        '        if degs[e[0]] == 1 and degs[e[1]] > 2:\n',...
        '            list_to_remove.append(e[0])\n',...
        '        if degs[e[1]] == 1 and degs[e[0]] > 2:\n',...
        '            list_to_remove.append(e[1])\n',...
        '    \n',...
        '    list_to_remove = list(set(list_to_remove))\n',...
        '    g.delete_vertices(list_to_remove)\n',...
        '    \n',...
        '    # Create new edge array\n',...
        '    edge_array = np.zeros((len(g.get_edgelist()), 2), dtype=np.int32)\n',...
        '    for i,e in enumerate(g.get_edgelist()):\n',...
        '        edge_array[i,0] = e[0]\n',...
        '        edge_array[i,1] = e[1]\n',...
        '    \n',...
        '    # Modified to avoid f-string syntax issues with nested quotes\n',...
        '    if isinstance(old_tree["Edges"], tuple):\n',...
        '        edges_removed = len(old_tree["Edges"][0]) - len(edge_array)\n',...
        '    else:\n',...
        '        edges_removed = len(old_tree["Edges"]) - len(edge_array)\n',...
        '    print(f"Removed {len(list_to_remove)} vertices and {edges_removed} edges")\n',...
        '    \n',...
        '    # Reconstruct edges in original format\n',...
        '    if edge_weights is not None:\n',...
        '        tree_elpi["Edges"] = (edge_array, edge_weights)\n',...
        '    else:\n',...
        '        tree_elpi["Edges"] = edge_array\n',...
        '    \n',...
        '    vs_subset = g.vs["label"]\n',...
        '    tree_elpi["NodePositions"] = nodes_positions[vs_subset,:]\n',...
        '    return tree_elpi\n\n',...
        'def extend_leaves(tree_elpi, X, mode="WeightedCentroid"):\n',...
        '    # Similar to ExtendLeaves_modified in the Python code\n',...
        '    TargetPG = copy.deepcopy(tree_elpi)\n',...
        '    \n',...
        '    # Create graph for leaf finding\n',...
        '    Net = nx.Graph()\n',...
        '    # Handle tuple format for edges\n',...
        '    edges_for_nx = TargetPG["Edges"][0] if isinstance(TargetPG["Edges"], tuple) else TargetPG["Edges"]\n',...
        '    Net.add_edges_from(edges_for_nx)\n',...
        '    LeafIDs = [n for n,d in Net.degree() if d == 1]\n',...
        '    Nei = [list(Net.neighbors(n)) for n in LeafIDs]\n',...
        '    NodesMat = np.column_stack((LeafIDs, [n[0] for n in Nei]))\n',...
        '    \n',...
        '    # Partition data\n',...
        '    PD = PartitionData(X=X,\n',...
        '                     NodePositions=TargetPG["NodePositions"],\n',...
        '                     MaxBlockSize=10000000,\n',...
        '                     TrimmingRadius=float("inf"),\n',...
        '                     SquaredX=np.sum(X**2, axis=1, keepdims=1))\n',...
        '    \n',...
        '    # Initialize variables for leaf extension\n',...
        '    NodeID = len(TargetPG["NodePositions"])-1\n',...
        '    init = False\n',...
        '    NNPos = None\n',...
        '    NEdgs = None\n',...
        '    UsedNodes = []\n',...
        '    \n',...
        '    # Extend each leaf\n',...
        '    for i in range(len(NodesMat)):\n',...
        '        if np.sum(PD[0] == NodesMat[i,0]) == 0:\n',...
        '            continue\n',...
        '        \n',...
        '        NodeID = NodeID + 1\n',...
        '        tData = X[(PD[0] == NodesMat[i,0]).flatten(),:]\n',...
        '        \n',...
        '        # Project points\n',...
        '        Proj = project_point_onto_edge(X=X[(PD[0] == NodesMat[i,0]).flatten(),:],\n',...
        '                                    NodePositions=TargetPG["NodePositions"],\n',...
        '                                    Edge=NodesMat[i,:])\n',...
        '        \n',...
        '        Dists = PD[1][PD[0] == NodesMat[i,0]]\n',...
        '        Dists[Proj["Projection_Value"] >= 0] = 0\n',...
        '        \n',...
        '        # Calculate weights based on mode\n',...
        '        if mode == "WeightedCentroid":\n',...
        '            Dist2 = Dists**(2*0.9)\n',...
        '            Wei = Dist2/np.max(Dist2) if np.max(Dist2) > 0 else Dist2\n',...
        '            \n',...
        '            # Calculate new node position\n',...
        '            if len(Wei) > 1:\n',...
        '                NN = np.sum(tData*Wei[:,None], axis=0)/np.sum(Wei)\n',...
        '            else:\n',...
        '                NN = tData\n',...
        '        else:\n',...
        '            # Default centroid method\n',...
        '            NN = np.mean(tData, axis=0) if len(tData) > 0 else tData\n',...
        '        \n',...
        '        # Store new node\n',...
        '        if not init:\n',...
        '            init = True\n',...
        '            NNPos = NN.copy()\n',...
        '            NEdgs = np.array([[NodesMat[i,0], NodeID]])\n',...
        '            UsedNodes.extend(list(np.where(PD[0].flatten() == NodesMat[i,0])[0]))\n',...
        '        else:\n',...
        '            NNPos = np.vstack((NNPos, NN))\n',...
        '            NEdgs = np.vstack((NEdgs, np.array([[NodesMat[i,0], NodeID]])))\n',...
        '            UsedNodes.extend(list(np.where(PD[0].flatten() == NodesMat[i,0])[0]))\n',...
        '    \n',...
        '    # Update tree with new nodes\n',...
        '    if init:\n',...
        '        TargetPG["NodePositions"] = np.vstack((TargetPG["NodePositions"], NNPos))\n',...
        '        # Handle tuple format when updating edges\n',...
        '        if isinstance(TargetPG["Edges"], tuple):\n',...
        '            # Add NaN weights for new edges if weights exist\n',...
        '            edge_weights = TargetPG["Edges"][1]\n',...
        '            new_weights = np.append(edge_weights, np.repeat(np.nan, len(NEdgs)))\n',...
        '            TargetPG["Edges"] = (np.vstack((TargetPG["Edges"][0], NEdgs)), new_weights)\n',...
        '        else:\n',...
        '            TargetPG["Edges"] = np.vstack((TargetPG["Edges"], NEdgs))\n',...
        '    \n',...
        '    return TargetPG\n\n',...
        'def load_and_process(vox_filepath, input_file, output_file):\n',...
        '    # Load data\n',...
        '    data = loadmat(input_file)\n',...
        '    X = data["X"]\n',...
        '    \n',...
        '    # Load the VOX file\n',...
        '    print(f"Loading VOX file: {vox_filepath}")\n',...
        '    with open(vox_filepath, "rb") as f:\n',...
        '        PGs = pickle.load(f)\n',...
        '    \n',...
        '    # Extract the tree (last element)\n',...
        '    tree_elpi = PGs[len(PGs)-1]\n',...
        '    \n',...
        '    # Modified to avoid f-string syntax issues with nested quotes\n',...
        '    nodes_count = len(tree_elpi["NodePositions"])\n',...
        '    if isinstance(tree_elpi["Edges"], tuple):\n',...
        '        edges_count = len(tree_elpi["Edges"][0])\n',...
        '    else:\n',...
        '        edges_count = len(tree_elpi["Edges"])\n',...
        '    print(f"Initial tree: {nodes_count} nodes, {edges_count} edges")\n',...
        '    \n',...
        '    # Prune the tree\n',...
        '    tree_elpi = prune_tree(tree_elpi)\n',...
        '    \n',...
        '    # Modified to avoid f-string syntax issues with nested quotes\n',...
        '    nodes_count = len(tree_elpi["NodePositions"])\n',...
        '    if isinstance(tree_elpi["Edges"], tuple):\n',...
        '        edges_count = len(tree_elpi["Edges"][0])\n',...
        '    else:\n',...
        '        edges_count = len(tree_elpi["Edges"])\n',...
        '    print(f"After pruning: {nodes_count} nodes, {edges_count} edges")\n',...
        '    \n',...
        '    # Extend leaves\n',...
        '    tree_extended = extend_leaves(tree_elpi, X, mode="WeightedCentroid")\n',...
        '    \n',...
        '    # Modified to avoid f-string syntax issues with nested quotes\n',...
        '    nodes_count = len(tree_extended["NodePositions"])\n',...
        '    if isinstance(tree_extended["Edges"], tuple):\n',...
        '        edges_count = len(tree_extended["Edges"][0])\n',...
        '    else:\n',...
        '        edges_count = len(tree_extended["Edges"])\n',...
        '    print(f"Final tree: {nodes_count} nodes, {edges_count} edges")\n',...
        '    \n',...
        '    # Save results - preserve edge format\n',...
        '    if isinstance(tree_extended["Edges"], tuple):\n',...
        '        # If edges is a tuple, save the first element (edge connections) as Edges\n',...
        '        # and the second element (weights) as EdgeWeights\n',...
        '        savemat(output_file, {\n',...
        '            "NodePositions": tree_extended["NodePositions"],\n',...
        '            "Edges": tree_extended["Edges"][0],\n',...
        '            "EdgeWeights": tree_extended["Edges"][1] if len(tree_extended["Edges"]) > 1 else []\n',...
        '        })\n',...
        '    else:\n',...
        '        savemat(output_file, {\n',...
        '            "NodePositions": tree_extended["NodePositions"],\n',...
        '            "Edges": tree_extended["Edges"]\n',...
        '        })\n',...
        '\n',...
        'if __name__ == "__main__":\n',...
        '    import sys\n',...
        '    load_and_process(sys.argv[1], sys.argv[2], sys.argv[3])\n']);
    % Save Python script
    script_file = 'temp_load_process.py';
    fid = fopen(script_file, 'w');
    fprintf(fid, '%s', python_script);
    fclose(fid);
    % Save input data
    input_file = 'temp_input.mat';
    output_file = 'temp_output.mat';
    save(input_file, 'X');
    % Execute Python script
    command = sprintf('"%s" "%s" "%s" "%s" "%s"', ...
        python_path, script_file, vox_filepath, input_file, output_file);
    [status, commandOutput] = system(command);
    if status ~= 0
        fprintf('Error output from Python:\n%s\n', commandOutput);
        error('Python script failed to execute properly');
    end
    % Load results
    tree_extended = load(output_file);
    % Print summary of loaded tree
    fprintf('Loaded tree has %d nodes and %d edges\n', ...
        size(tree_extended.NodePositions, 1), size(tree_extended.Edges, 1));
    % Clean up temporary files
    delete(input_file);
    delete(output_file);
    delete(script_file);
end
