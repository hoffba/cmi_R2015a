function [all_trajectories, all_trajectories_edges] = extract_trajectories_from_python(tree_elpi, root_node)
    
    
    % 1) Create Python script for trajectory extraction
    python_path = update_python_paths();
    python_script = sprintf(['import numpy as np\n',...
        'import igraph\n',...
        'from scipy.io import savemat, loadmat\n\n',...
        'def extract_trajectories(tree, root_node):\n',...
        '    # Get edges and node positions\n',...
        '    edges = tree["Edges"]\n',...
        '    nodes_positions = tree["NodePositions"]\n',...
        '    \n',...
        '    # Create igraph graph\n',...
        '    g = igraph.Graph()\n',...
        '    g.add_vertices(len(nodes_positions))\n',...
        '    g.add_edges(edges)\n',...
        '    \n',...
        '    # Find leaf nodes (degree=1)\n',...
        '    degs = g.degree()\n',...
        '    leaf_nodes = [i for i,d in enumerate(degs) if d==1]\n',...
        '    \n',...
        '    # Get shortest paths from root_node to each leaf\n',...
        '    all_trajectories_vertices = []\n',...
        '    all_trajectories_edges = []\n',...
        '    for lf in leaf_nodes:\n',...
        '        path_vertices = g.get_shortest_paths(root_node, to=lf, output="vpath")[0]\n',...
        '        path_edges = g.get_shortest_paths(root_node, to=lf, output="epath")[0]\n',...
        '        all_trajectories_vertices.append(path_vertices)\n',...
        '        all_trajectories_edges.append(path_edges)\n',...
        '    return all_trajectories_vertices, all_trajectories_edges\n\n',...
        'def compute_trajectories(input_file, output_file):\n',...
        '    # Load data from MAT file\n',...
        '    data = loadmat(input_file)\n',...
        '    tree = {\n',...
        '        "NodePositions": data["NodePositions"],\n',...
        '        "Edges": data["Edges"]\n',...
        '    }\n',...
        '    root_node = int(data["root_node"].item())\n',...
        '    trajectories, edges = extract_trajectories(tree, root_node)\n',...
        '    \n',...
        '    # Convert to NumPy arrays with padding\n',...
        '    max_traj_len = max(len(t) for t in trajectories)\n',...
        '    max_edge_len = max(len(e) for e in edges)\n',...
        '    \n',...
        '    traj_array = np.full((len(trajectories), max_traj_len), -1)\n',...
        '    edge_array = np.full((len(trajectories), max_edge_len), -1)\n',...
        '    \n',...
        '    for i, traj in enumerate(trajectories):\n',...
        '        traj_array[i, :len(traj)] = traj\n',...
        '    for i, ed in enumerate(edges):\n',...
        '        edge_array[i, :len(ed)] = ed\n',...
        '    \n',...
        '    # Save results to output MAT file\n',...
        '    savemat(output_file, {\n',...
        '        "trajectories": traj_array,\n',...
        '        "trajectory_edges": edge_array\n',...
        '    })\n\n',...
        'if __name__ == "__main__":\n',...
        '    import sys\n',...
        '    compute_trajectories(sys.argv[1], sys.argv[2])\n']);
    script_file = 'temp_extract_traj.py';
    fid = fopen(script_file, 'w');
    fprintf(fid, '%s', python_script);
    fclose(fid);
    
    % 2) Prepare input MAT file for Python
    input_file = 'temp_traj_input.mat';
    output_file = 'temp_traj_output.mat';
    
    % If 'Edges' is in a cell, extract the numeric array
    if iscell(tree_elpi.Edges)
        Edges = tree_elpi.Edges{1};
    else
        Edges = tree_elpi.Edges;
    end
    NodePositions = tree_elpi.NodePositions;
    
   
    save(input_file, 'NodePositions', 'Edges', 'root_node');
    % Execute Python script
    command = sprintf('"%s" "%s" "%s" "%s"', ...
    python_path, script_file, input_file, output_file);
    [status, commandOutput] = system(command);
    
    if status ~= 0
        fprintf('Python script failed with error:\n%s\n', cmdout);
        error('Python script execution failed');
    end
    
    % 4) Load the results back into MATLAB
    results = load(output_file);
    traj_array = results.trajectories;
    edge_array = results.trajectory_edges;
    
    % Convert them to cell arrays WITHOUT adding 1
    nTraj = size(traj_array, 1);
    all_trajectories = cell(nTraj, 1);
    all_trajectories_edges = cell(nTraj, 1);
    
    for i = 1:nTraj
        valid_traj  = traj_array(i, traj_array(i,:)  >= 0);
        valid_edges = edge_array(i, edge_array(i,:) >= 0);
        all_trajectories{i}       = valid_traj;   % no +1 shift
        all_trajectories_edges{i} = valid_edges;  % no +1 shift
    end
    
    % 5) Print a summary
    fprintf('\n%d trajectories found.\n', nTraj);
    for i = 1:nTraj
        fprintf('Trajectory %d: %d nodes, from node %d to node %d\n', ...
            i, length(all_trajectories{i}), ...
            all_trajectories{i}(1), all_trajectories{i}(end));
    end
    
    % 6) Clean up temp files
    delete(input_file);
    delete(output_file);
    delete(script_file);
end
