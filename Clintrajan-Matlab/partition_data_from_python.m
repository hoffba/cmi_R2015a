function [vec_labels_by_branches, partition_by_node] = partition_data_from_python(X, tree_elpi)
    % Create Python script for partitioning
    python_path = update_python_paths();
    python_script = sprintf(['import numpy as np\n',...
        'import elpigraph\n',...
        'import igraph\n',...
        'from elpigraph.src.core import PartitionData\n',...
        'from elpigraph.src.reporting import project_point_onto_graph\n',...
        'from scipy.io import savemat, loadmat\n\n',...
        'def partition_data(Xcp, NodePositions, MaxBlockSize=10**6, SquaredXcp=None, TrimmingRadius=float("inf")):\n',...
        '    if SquaredXcp is None:\n',...
        '        SquaredXcp = np.sum(Xcp**2, 1)[:,np.newaxis]\n',...
        '    NodePositionscp = np.asarray(NodePositions)\n',...
        '    n = Xcp.shape[0]\n',...
        '    partition = np.zeros((n, 1), dtype=int)\n',...
        '    dists = np.zeros((n, 1))\n',...
        '    all_dists = np.zeros((n, NodePositions.shape[0]))\n',...
        '    cent = NodePositionscp.T\n',...
        '    centrLength = (cent**2).sum(axis=0)\n',...
        '    for i in range(0, n, MaxBlockSize):\n',...
        '        last = min(i+MaxBlockSize, n)\n',...
        '        d = SquaredXcp[i:last] + centrLength-2*np.dot(Xcp[i:last,], cent)\n',...
        '        tmp = d.argmin(axis=1)\n',...
        '        partition[i:last] = tmp[:,np.newaxis]\n',...
        '        dists[i:last] = d[np.arange(d.shape[0]), tmp][:,np.newaxis]\n',...
        '        all_dists[i:last,:] = d\n',...
        '    if not np.isinf(TrimmingRadius):\n',...
        '        ind = dists > (TrimmingRadius**2)\n',...
        '        partition[ind] = -1\n',...
        '        dists[ind] = TrimmingRadius**2\n',...
        '    return np.asarray(partition), np.asarray(dists), np.asarray(all_dists)\n\n',...
        'def find_branches(graph, verbose=0):\n',...
        '    g = graph\n',...
        '    n_vertices_input_graph = g.vcount()\n',...
        '    set_vertices_input_graph = range(n_vertices_input_graph)\n',...
        '    dict_output = {}\n',...
        '    found_branches = []\n',...
        '    processed_edges = []\n',...
        '    processed_vertices = set()\n',...
        '    def find_start_vertex(g, processed_vertices):\n',...
        '        if n_vertices_input_graph == len(processed_vertices):\n',...
        '            return -1, -1\n',...
        '        for v in set_vertices_input_graph:\n',...
        '            if v in processed_vertices: continue\n',...
        '            if g.degree(v) != 2:\n',...
        '                return v, 1\n',...
        '        return -1, 0\n',...
        '    def find_branches_core(current_vertex, previous_vertex, current_branch):\n',...
        '        processed_vertices.add(current_vertex)\n',...
        '        neis = g.neighbors(current_vertex)\n',...
        '        if len(neis) == 0:\n',...
        '            found_branches.append([current_vertex])\n',...
        '            return\n',...
        '        if len(neis) == 1:\n',...
        '            if neis[0] == previous_vertex:\n',...
        '                current_branch.append(current_vertex)\n',...
        '                found_branches.append(current_branch.copy())\n',...
        '                return\n',...
        '            else:\n',...
        '                current_branch = [current_vertex]\n',...
        '                processed_edges.append(set([current_vertex, neis[0]]))\n',...
        '                find_branches_core(neis[0], current_vertex, current_branch)\n',...
        '                return\n',...
        '        if len(neis) == 2:\n',...
        '            current_branch.append(current_vertex)\n',...
        '            next_vertex = neis[1] if neis[0] == previous_vertex else neis[0]\n',...
        '            if next_vertex in processed_vertices:\n',...
        '                if set([current_vertex, next_vertex]) not in processed_edges:\n',...
        '                    current_branch.append(next_vertex)\n',...
        '                    found_branches.append(current_branch.copy())\n',...
        '                    processed_edges.append(set([current_vertex, next_vertex]))\n',...
        '                return\n',...
        '            processed_edges.append(set([current_vertex, next_vertex]))\n',...
        '            find_branches_core(next_vertex, current_vertex, current_branch)\n',...
        '            return\n',...
        '        if len(neis) > 2:\n',...
        '            if previous_vertex is not None:\n',...
        '                current_branch.append(current_vertex)\n',...
        '                found_branches.append(current_branch.copy())\n',...
        '            for next_vertex in neis:\n',...
        '                if next_vertex == previous_vertex: continue\n',...
        '                if next_vertex in processed_vertices:\n',...
        '                    if set([current_vertex, next_vertex]) not in processed_edges:\n',...
        '                        processed_edges.append(set([current_vertex, next_vertex]))\n',...
        '                        found_branches.append([current_vertex, next_vertex])\n',...
        '                    continue\n',...
        '                current_branch = [current_vertex]\n',...
        '                processed_edges.append(set([current_vertex, next_vertex]))\n',...
        '                find_branches_core(next_vertex, current_vertex, current_branch)\n',...
        '        return\n',...
        '    while True:\n',...
        '        initial_vertex, flag_found_start_vertex = find_start_vertex(g, processed_vertices)\n',...
        '        if flag_found_start_vertex > 0:\n',...
        '            current_vertex = initial_vertex\n',...
        '        elif flag_found_start_vertex == 0:\n',...
        '            tmp_set = set_vertices_input_graph - processed_vertices\n',...
        '            current_vertex = next(iter(tmp_set))\n',...
        '        else:\n',...
        '            dict_output["branches"] = found_branches.copy()\n',...
        '            return dict_output\n',...
        '        processed_vertices.add(current_vertex)\n',...
        '        find_branches_core(current_vertex, None, [])\n',...
        '    return dict_output\n\n',...
        'def branch_labler(X, graph, nodes_positions, verbose=0):\n',...
        '    dict_output = find_branches(graph, verbose=verbose)\n',...
        '    vec_labels_by_vertices, dists, all_dists = partition_data(X, nodes_positions)\n',...
        '    vec_labels_by_vertices = vec_labels_by_vertices.ravel()\n',...
        '    n_vertices = len(nodes_positions)\n',...
        '    branches = dict_output["branches"]\n',...
        '    dict_vertex2branches = {}\n',...
        '    for i,b in enumerate(branches):\n',...
        '        for v in b:\n',...
        '            if v in dict_vertex2branches.keys():\n',...
        '                dict_vertex2branches[v].append(i)\n',...
        '            else:\n',...
        '                dict_vertex2branches[v] = [i]\n',...
        '    list_branch_vertices = []\n',...
        '    list_non_branch_vertices = []\n',...
        '    for v in dict_vertex2branches:\n',...
        '        list_branches = dict_vertex2branches[v]\n',...
        '        if len(list_branches) == 1:\n',...
        '            list_non_branch_vertices.append(v)\n',...
        '        else:\n',...
        '            list_branch_vertices.append(v)\n',...
        '    vec_vertex2branch = np.zeros(n_vertices)\n',...
        '    for i in range(n_vertices):\n',...
        '        vec_vertex2branch[i] = dict_vertex2branches[i][0]\n',...
        '    vec_labels_by_branches = vec_vertex2branch[vec_labels_by_vertices]\n',...
        '    for branch_vertex in list_branch_vertices:\n',...
        '        mask = vec_labels_by_vertices == branch_vertex\n',...
        '        dist2branches = np.zeros([mask.sum(), len(dict_vertex2branches[branch_vertex])])\n',...
        '        list_branch_ids = []\n',...
        '        for i,branch_id in enumerate(dict_vertex2branches[branch_vertex]):\n',...
        '            list_branch_ids.append(branch_id)\n',...
        '            branch_vertices_wo_given_branch_vertex = [v for v in branches[branch_id] if v != branch_vertex]\n',...
        '            dist2branches[:,i] = np.min(all_dists[mask,:][:,branch_vertices_wo_given_branch_vertex], 1).ravel()\n',...
        '        vec_labels_by_branches[mask] = np.array(list_branch_ids)[np.argmin(dist2branches, 1)]\n',...
        '    return vec_labels_by_branches\n\n',...
        'def compute_partitions(input_file, output_file):\n',...
        '    data = loadmat(input_file)\n',...
        '    X = data["X"]\n',...
        '    node_positions = data["NodePositions"]\n',...
        '    edges = data["Edges"]\n',...
        '    g = igraph.Graph()\n',...
        '    g.add_vertices(len(node_positions))\n',...
        '    g.add_edges([(int(e[0]), int(e[1])) for e in edges])\n',...
        '    vec_labels = branch_labler(X, g, node_positions)\n',...
        '    squared_X = np.sum(X**2, axis=1, keepdims=1)\n',...
        '    partition = PartitionData(X=X, NodePositions=node_positions, MaxBlockSize=100000000, \n',...
        '                          TrimmingRadius=float("inf"), SquaredX=squared_X)[0]\n',...
        '    savemat(output_file, {\n',...
        '        "vec_labels_by_branches": vec_labels,\n',...
        '        "partition_by_node": partition.flatten()\n',...
        '    })\n\n',...
        'if __name__ == "__main__":\n',...
        '    import sys\n',...
        '    compute_partitions(sys.argv[1], sys.argv[2])\n']);
    % Save script and execute
    script_file = 'temp_partition_script.py';
    fid = fopen(script_file, 'w');
    fprintf(fid, '%s', python_script);
    fclose(fid);
    
    % Prepare input data
    input_file = 'temp_partition_input.mat';
    output_file = 'temp_partition_output.mat';
    
    % Handle Edges format
    if iscell(tree_elpi.Edges)
        Edges = tree_elpi.Edges{1};
    else
        Edges = tree_elpi.Edges;
    end
    NodePositions = tree_elpi.NodePositions;
    
    % Save input data
    save(input_file, 'X', 'NodePositions', 'Edges');
    
    % Execute Python script
    command = sprintf('"%s" "%s" "%s" "%s"', ...
    python_path, script_file, input_file, output_file);
    [status, commandOutput] = system(command);
    
    if status ~= 0
        fprintf('Python script failed with error:\n%s\n', cmdout);
        error('Python script execution failed');
    end
    
    % Load results
    results = load(output_file);
    vec_labels_by_branches = results.vec_labels_by_branches;
    partition_by_node = results.partition_by_node;
    
    % Clean up
    delete(input_file);
    delete(output_file);
    delete(script_file);
end
